int* GPIO_OUTPUT_ENABLE = (int*) 0x60091024; //0x6009_1000 + 0x24 GPIO BASE + OFFSET FOR OUTPUT ENABLE
int* GPIO_OUTPUT_SET    = (int*) 0x60091008;
int* GPIO_OUTPUT_CLEAR  = (int*) 0x6009100C;
int* IO_MUX_GPIO4       = (int*) 0x60090014; //0x6009_0000 + 0x14 IO MUX BASE + OFFSET FOR GPIO 4
int* IO_MUX_GPIO7       = (int*) 0x60090020; //0x6009_0000 + 0x20 IO MUX BASE + OFFSET FOR GPIO 7
int* GPIO_INPUT         = (int*) 0x6009103C; //The register that holds inputs from the GPIO pins

void setup() {
  asm volatile(
    // Enable GPIO7 as output
    "li   t0, 0x60091024\n"      // *GPIO_OUTPUT_ENABLE |= 0x80;
    "lw   t1, 0(t0)\n"
    "ori  t1, t1, 0x80\n"
    "sw   t1, 0(t0)\n"

    // Ensure GPIO4 input with pull-down enabled
    "li   t0, 0x60090014\n"      // *IO_MUX_GPIO4 |= 0x280;
    "lw   t1, 0(t0)\n"
    "ori  t1, t1, 0x280\n"
    "sw   t1, 0(t0)\n"

    // Configure GPIO7 mux bits
    "li   t0, 0x60090020\n"      // *IO_MUX_GPIO7 |= 0x1000;
    "lw   t1, 0(t0)\n"
    "ori  t1, t1, 0x1000\n"
    "sw   t1, 0(t0)\n"
  );
}

void loop() {
  asm volatile(
    // Read GPIO input register and test bit 4
    "li   t0, 0x6009103C\n"      // if((*GPIO_INPUT & (1 << 4)) == 0)
    "lw   t1, 0(t0)\n"
    "andi t2, t1, 0x10\n"
    "bnez t2, else\n"

    // if: clear GPIO7 output
    "li   t0, 0x6009100C\n"      // *GPIO_OUTPUT_CLEAR = 0x80;
    "li   t1, 0x80\n"
    "sw   t1, 0(t0)\n"
    "j    skipElse\n"

    // else: set GPIO7 output
    "else:\n"
    "li   t0, 0x60091008\n"      // *GPIO_OUTPUT_SET = 0x80;
    "li   t1, 0x80\n"
    "sw   t1, 0(t0)\n"

    "skipElse:\n"
  );
}
